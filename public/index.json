[
  {
    "content": "Chapter 1 Basic Lorem Ipsum.\n",
    "description": "",
    "tags": null,
    "title": "Basics",
    "uri": "/basics/"
  },
  {
    "content": "Chapter X Some Chapter title Lorem Ipsum.\n",
    "description": "",
    "tags": null,
    "title": "JavaScript相关",
    "uri": "/javascript%E7%9B%B8%E5%85%B3/"
  },
  {
    "content": " title: “ES6版选项卡” date: 2022-03-02T23:34:24+08:00 ES6版选项卡 ES6 AJAX function ajax(url){\rreturn new Promise((succ,error)=\u003e{\rvar ajax= new XMLHttpRequest();\rajax.open('get',url,true);\rajax.send;\rajax.onload=function(){\rsucc(ajsx.responseText);\r};\rajax.onerror=function(){\rerror();\r};\r}).then((text)=\u003e{\rcosole.log(text);\r}).catch(()=\u003e{\rconsole.log(1);\r})\r}\r",
    "description": "",
    "tags": [
      "tutorial",
      "theme"
    ],
    "title": "Theme tutorial",
    "uri": "/javascript%E7%9B%B8%E5%85%B3/es6/es6-demo/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "DSF",
    "uri": "/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Pythons",
    "uri": "/python/"
  },
  {
    "content": "PYTHON爬虫系列 定义存储字段和管道类 items.py 主要用于存储对象\nItem对象  pipeline.py 用于实现对象存储（歌曲入库）和对象操作（歌曲下载）\n触发对Item对象的操作，实现类初始化和数据库连接。  Spider开发之Get请求和Post请求 Post是传递参数（需要搜索的参数）到服务器，而Get请求是指明url。\nSelector选择器会用XPATH和CSS表达式选择HTML中的部分数据。\n然后用可以重用的Item pipelines进行文件下载和保存。\nSCRAPY爬虫的运行方式  调度器中取出URL封装成Request请求给下载器 资源下载后封装成Response 解析出实体Item给pipeline处理 解析出URL则给调度器等待抓取  ",
    "description": "",
    "tags": null,
    "title": "SCRAPY",
    "uri": "/python/scrapy/"
  },
  {
    "content": "M3系列文章概览\n   M3R的结构特征/功能作用/G蛋白偶联特异性的决定       Receptor 药用靶标 G protein     M1 神经系统疾病（如阿尔茨海默病和精神分裂症）/学习、记忆和认知 Gq/11   M2 调节人体心率和许多中枢神经系统功能 Gi/o   M3 激活后受体磷酸化，募集b抑制蛋白能力受损 / 糖耐量受损伴随着M3受体介导的胰岛胰岛素释放降低 Gq/11   M4 神经系统疾病（如阿尔茨海默病和精神分裂症） /学习、记忆和认知 Gi/o    inverse agonist, tiotropium\nPositive allosteric modulators/正变构调节剂 (PAM)\nSAR, structure–activity relationship\n(Q)SAR 也是模型或数学关系（通常是统计相关性），它将与结构相关的特性与另一个感兴趣的特性或活动的存在或不存在或效力相关联。(Q)SAR最基本的数学形式是：\n活性 = f（物理化学或结构特性）  SARs 模型的开发需要三个组件：\n  为一组化学品（即因变量）提供活性（通常通过实验测量）的数据集。这组化学品通常由一些选择标准定义。因变量通常是可监测活性。\n  同一组化学品的结构标准或与结构相关的特性数据集（即自变量）。自变量通常是结构属性。\n  关联这两个数据数组的方法（通常是统计分析方法）。将结构与活动联系起来的方法范围从简单的线性回归，到更复杂的方法（例如偏最小二乘分析），再到最复杂的机器学习技术（例如神经网络）。\n    正构结合位点的比较/选择性    ligand结合的动态变化    2018- Structure-guided development of selective M3 muscarinic acetylcholine receptor antagonists  M3 muscarinic acetylcholine receptor (M3R) antagonist chronic obstructive pulmonary disease （COPD）  比较M2R和M3R的正构结合位点 M3R的Tiotropium会识别非保守残基亮氨酸，M2R的QNB识别非保守残基苯丙氨酸。compound c的docking pose表明一个扩大的向上环可以越过M2R的非保守苯丙氨酸。\nStructure-based ligand design  up-righting and rotation of ring B steric interactions with Phe181 for compound 6b 键的迁移 构象的限制 卤化   这篇文章找到了一个cmpd 6o（BS46），在小鼠体内验证了可以降低心率和降低气道阻力的功能。解了M3R与选择性拮抗剂6o (BS46) 复合的晶体结构。M3R的ICL3的细胞内环替换成mT4L。而在M2R中因为Phe181的空间阻碍而不能与6o结合。从而实现在比M2R选择性提高100倍，在体内有1000倍的选择性的效果。6o是根据M2R的拮抗剂QNB来设计的。\n2012- Structure and dynamics of the M3 muscarinic acetylcholine receptor M3R的主要结构特征 accessible surface for the M3 receptor bound to tiotropium (spheres) shows the receptor covering the ligand with a tyrosine lid (outlined in red).\nM3 receptor structure coloured by sequence conservation among the five mAChR subtypes. Poorly conserved regions are shown with larger backbone diameter. The orthosteric and allosteric sites are indicated in blue and red elliptical shaded areas, respectively, and the ligand tiotropium is shown as spheres.\nligand结合的动态变化 结合位点附近的 M2 和 M3 受体之间存在 Phe (M2)/Leu (M3) 序列差异。这会在 M3 受体中产生一个扩大的结合袋，用红色勾勒并用箭头表示。M3 Y5297.39 和 D1473.32 的位移(黑色虚线); Y5297.39 的位移可能源于 2.61 位的序列差异（M2 中的 Tyr 80 和 M3 中的 Phe 124）。\nG蛋白偶联特异性的决定条件 Distances were measured between Ca atoms of TM5 residue 5.62 and TM3 residue 3.54 (x-axis), and TM5 residue 5.62 and TM6 residue 6.37 (y-axis).\nStructural alignment of mammalian Gi/o-coupled and Gq/11-coupled receptor structures.\n2017- Structure-based discovery of selective positive allosteric modulators of antagonists for the M2 muscarinic acetylcholine receptor 发现了M2 antagonist的PAM 628分子。\n2014- Muscarinic acetylcholine receptors: novel opportunities for drug development 【Feather】 毒蕈碱乙酰胆碱受体是调节中枢和外周神经系统的许多基本功能的 G 蛋白偶联受体亚家族。\nT2D 2 型糖尿病的关键病理生理特征之一是胰腺 β 细胞无法分泌足够的胰岛素来克服外周胰岛素抵抗。\nβ 细胞 M3 受体促进胰岛素释放的能力取决于 Gq 家族 G 蛋白的存在； M3 receptor-mediated activation of arrestin-dependent β-cell pathways may further enhance insulin secretion；\nModes of targeting mAChRs (GPCRs) by different classes of ligands：   Orthosteric\n  allosteric\n achieve greater receptor selectivity and promote more physiological response patterns    bitopic\n target the allosteric site to achieve selectivity and the orthosteric site to provide high affinity.    2013- Activation and allosteric modulation of a muscarinic acetylcholine receptor 用酵母库筛选nanobody的方法找到nanobody9-8，并解析正构结合激动剂iperoxo和nanobody复合物结构。\n2019- Structures of the M1 and M2 muscarinic acetylcholine receptor/G-protein complexes 解析了M1R和G11复合物结构，M2R和Go的复合物电镜结构。\n2016- Crystal structures of the M1 and M4 muscarinic acetylcholine receptors M1-M4的结构对比\nM1-M4正构异构结合位点残基比较\nM4R的共建网络\n2019- Conformational Complexity and Dynamics in a Muscarinic Receptor Revealed by NMR Spectroscopy M2R结合ligand的动态landscape\n2013- Muscarinic Receptors as Model Targets and Antitargets for Structure-Based Ligand Discovery 【Feather】 In the M3 receptor, M2 Phe181 is replaced by a leucine\nDocking poses for selected M2 muscarinic receptor hits. Docking for selective M3 receptor ligands. 一些M2的ligand因为M3R的结合口袋更加亲水，溶剂可及性更好，会表现出对M3更高的亲和力。\nCompound 16 activates M3 but not M2 receptors. ",
    "description": "",
    "tags": null,
    "title": "M3 Muscarinic Acetylcholine Receptors Overview",
    "uri": "/structure/m3-muscarinic-acetylcholine-receptors-overview/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Structures",
    "uri": "/structure/"
  },
  {
    "content": "this fold is under basic ##Be happy\nno one can harm you! ",
    "description": "",
    "tags": null,
    "title": "Second Content",
    "uri": "/basics/second-content/"
  },
  {
    "content": "Basic下的一篇文章 我只想看看他有没有。\n",
    "description": "",
    "tags": null,
    "title": "First Content",
    "uri": "/basics/second-content/first-content/"
  },
  {
    "content": "Variable elevation; Event bubble; Prototype 变量提升 预解析；变量提升到最上面，值不变；只有有作用域的位置才会发生变量提升。\nJS的变量具有唯一性，变量提升的变量会覆盖掉前面的定义值。\n函数的变量提升优先级次于变量。函数变量提升的值可以提升。\n事件冒泡 子级元素会继承父级元素的事件。\nevent.cancelBubble=true; 阻止事件冒泡,防止父级的事件到子级中。\n原型 原型链给原型加方法。\n原型可以用json的方法去赋予。\n\u003c!DOCTYPE html\u003e\r\u003chtml lang=\"en\"\u003e\r\u003chead\u003e\r\u003cmeta charset=\"UTF-8\"\u003e\r\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\r\u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e\r\u003ctitle\u003eDocument\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody\u003e\r\u003cscript type=\"text/javascript\"\u003e\rArray.prototype.zs=function(){\ralert(this);\r};\r[1,2,3].zs();\rFunction.prototype.zs=function(){\ralert(\"dont speak now\");\r};\rfunction a(){};\ra.zs();\r\u003c/script\u003e\r\u003c/body\u003e\r\u003c/html\u003e\r继承原型 a.prototype=b.prototype more definited you can set a.prototype.nn=b.prototype.nn\nnew a().nn()\njson的方法赋值 a.prototype={\r'mm':function(){\ralert(this.a+this.b);\r},\r'nn':function(){\ralert(2);\r}\r}\rAJAX(AHR) get\npost\n同步\n异步\n后台语言： php .net java nodeJS\n服务器的状态码：2成功；3重定向；4失败\n状态码：怎么把responseText弄出来\najax readyState\n0 - (未初始化)还没有调用send()方法\r1 - (载入)已调用send()方法，正在发送请求\r2 - (载入完成)send()方法执行完成，\r3 - (交互)正在解析响应内容\r4 - (完成)响应内容解析完成，可以在客户端调用了\rajax.onreadystatechange=function(){\rif(ajax.readyState==4){\rconsole.log(ajax.responseText)\rconsole.log(ajax.status)\r}\r// console.log('ajax.readyState');\r}\rnodeJS优点：\n nodeJS 比 php快86倍 VUE和REACT都基于nodeJS 基于cmd，编译型语言非内置  第一个nodejs脚本 var http= require('http');\rhttp.createServer(function(request,response){\rconsole.log(request.url);\r}).listen(9217);\r// 返回监听的9217端口的url\rvar http= require('http');\rhttp.createServer(function(request,response){\r// console.log(request.url);\rresponse.setHeader('Access-Control-Allow-Origin','*')\r\u003c!-- 实现跨域 --\u003e\rconsole.log('sb coming');\r// 只要有请求来控制台就会输出提示\rresponse.write('Im LauYing');\rresponse.end();\r}).listen(9217);\r前端脚本 var ajax= new XMLHttpRequest();\rajax.open('get','http://localhost:9217/',false);\r// 新建一个和后台服务器交换数据的对象，打开一个本地的端口，同步干完一条命令才下一条，异步分开干。\rajax.send();\rconsole.log(ajax.responseText)\r",
    "description": "",
    "tags": null,
    "title": "java学习",
    "uri": "/post/second-content/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Posts",
    "uri": "/post/"
  },
  {
    "content": "Promise promise是个对象\n只要触发就完成了任务结束生命周期。 可以无限回调\nnew Promise(function(Resolved,Reject){\rResolved();\r}).then(function(){\ralert('成功')\r},function(){\ralert('失败')\r})\rfunction showPromise(res){\rreturn new Promise((resolve,reject)=\u003e{\rresolved(res)\r}).then ((x)=\u003e{console.log(x)},()=\u003e{\r})\r}\rshowPromise('yours');\r实现点击显示循环\nlet index=0;\ript.onclick=x=\u003e{\rindex++;\rnew Promise((succ,error)=\u003e{\rindex%2==1?succ();error();\r}).then(()=\u003e{\rdiv1.style.display='none';\r},()=\u003e{\rdiv1.style.display='block';\r})\r};\rthen(成功函数).catch(失败函数)\nthrow 抛出异常\nrace 竞速方法 只看第一个执行完成的promise\nall 要不然就是全胜要么全部失败，全部成功就全部输出\nWebwork ",
    "description": "",
    "tags": null,
    "title": "Promise",
    "uri": "/javascript%E7%9B%B8%E5%85%B3/es6/es6-promise%E5%AF%B9%E8%B1%A1/"
  },
  {
    "content": "Variable elevation; Event bubble; Prototype 变量提升 预解析；变量提升到最上面，值不变；只有有作用域的位置才会发生变量提升。\nJS的变量具有唯一性，变量提升的变量会覆盖掉前面的定义值。\n函数的变量提升优先级次于变量。函数变量提升的值可以提升。\n事件冒泡 子级元素会继承父级元素的事件。\nevent.cancelBubble=true; 阻止事件冒泡,防止父级的事件到子级中。\n原型 原型链给原型加方法。\n原型可以用json的方法去赋予。\n\u003c!DOCTYPE html\u003e\r\u003chtml lang=\"en\"\u003e\r\u003chead\u003e\r\u003cmeta charset=\"UTF-8\"\u003e\r\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\r\u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e\r\u003ctitle\u003eDocument\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody\u003e\r\u003cscript type=\"text/javascript\"\u003e\rArray.prototype.zs=function(){\ralert(this);\r};\r[1,2,3].zs();\rFunction.prototype.zs=function(){\ralert(\"dont speak now\");\r};\rfunction a(){};\ra.zs();\r\u003c/script\u003e\r\u003c/body\u003e\r\u003c/html\u003e\r继承原型 a.prototype=b.prototype more definited you can set a.prototype.nn=b.prototype.nn\nnew a().nn()\njson的方法赋值 a.prototype={\r'mm':function(){\ralert(this.a+this.b);\r},\r'nn':function(){\ralert(2);\r}\r}\rAJAX(AHR) get\npost\n同步\n异步\n后台语言： php .net java nodeJS\n服务器的状态码：2成功；3重定向；4失败\n状态码：怎么把responseText弄出来\najax readyState\n0 - (未初始化)还没有调用send()方法\r1 - (载入)已调用send()方法，正在发送请求\r2 - (载入完成)send()方法执行完成，\r3 - (交互)正在解析响应内容\r4 - (完成)响应内容解析完成，可以在客户端调用了\rajax.onreadystatechange=function(){\rif(ajax.readyState==4){\rconsole.log(ajax.responseText)\rconsole.log(ajax.status)\r}\r// console.log('ajax.readyState');\r}\rnodeJS优点：\n nodeJS 比 php快86倍 VUE和REACT都基于nodeJS 基于cmd，编译型语言非内置  第一个nodejs脚本 var http= require('http');\rhttp.createServer(function(request,response){\rconsole.log(request.url);\r}).listen(9217);\r// 返回监听的9217端口的url\rvar http= require('http');\rhttp.createServer(function(request,response){\r// console.log(request.url);\rresponse.setHeader('Access-Control-Allow-Origin','*')\r\u003c!-- 实现跨域 --\u003e\rconsole.log('sb coming');\r// 只要有请求来控制台就会输出提示\rresponse.write('Im LauYing');\rresponse.end();\r}).listen(9217);\r前端脚本 var ajax= new XMLHttpRequest();\rajax.open('get','http://localhost:9217/',false);\r// 新建一个和后台服务器交换数据的对象，打开一个本地的端口，同步干完一条命令才下一条，异步分开干。\rajax.send();\rconsole.log(ajax.responseText)\r",
    "description": "",
    "tags": null,
    "title": "重名了改一下",
    "uri": "/post/a/"
  },
  {
    "content": "我就想看看没有文件夹能否显示子页面。\n",
    "description": "",
    "tags": null,
    "title": "JavaScript",
    "uri": "/post/javascript/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "theme",
    "uri": "/tags/theme/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "tutorial",
    "uri": "/tags/tutorial/"
  }
]
